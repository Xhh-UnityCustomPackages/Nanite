#pragma kernel CSMain

#include "../Library/GPUInstanceDefine.hlsl"

//Item数据
StructuredBuffer<uint> _RenderIDBuffer;
StructuredBuffer<uint> _CullResultBuffer;
StructuredBuffer<uint> _LODLevelBuffer;
//Args数据
StructuredBuffer<IndirectArgs> _IndirectArgsBuffer;   //ArgsBuffer
int _ItemCount;//总物体数量

//排序数据 按照 AAABBCCCCDDDDDFFFFF 这样start offset来存放数据
RWStructuredBuffer<uint> _SortIDBuffer;
RWStructuredBuffer<uint> _InsertCountBuffer;

[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int itemIndex = id.x;
    
    if (itemIndex >= _ItemCount)
        return;
    
    bool isVisible = _CullResultBuffer[itemIndex];
    if (isVisible)
    {
        int renderID = _RenderIDBuffer[itemIndex];
        int lod = _LODLevelBuffer[itemIndex];
        IndirectArgs args = _IndirectArgsBuffer[renderID * LOD_LEVEL + lod];

        // 使用原子操作增加计数，并获取增加前的值
        uint originalCount;
        InterlockedAdd(_InsertCountBuffer[renderID * LOD_LEVEL + lod], 1, originalCount);

        int offsetIndex = args.startLocation + originalCount;
        _SortIDBuffer[offsetIndex] = itemIndex;
    }
}
