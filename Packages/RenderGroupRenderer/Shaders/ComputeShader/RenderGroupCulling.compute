#pragma kernel CSMain
// #pragma kernel CSMainLOD

#include "../Library/GPUInstanceDefine.hlsl"
#include "../Library/LOD.hlsl"

#include "Packages/rendergrouprenderer/Runtime/OcclusionCulling/OcclusionCullingCommon.hlsl"

//相机参数
float3 _CameraPosition;
StructuredBuffer<float4> _FrustumPlanesBuffer; // 每个平面用float4表示，xyz为法线，w为距离
//Item数据
StructuredBuffer<Bounds> _BoundsBuffer;
StructuredBuffer<uint> _RenderIDBuffer;
RWStructuredBuffer<uint> _CullResultBuffer;
RWStructuredBuffer<uint> _LODLevelBuffer;
//Type数据
StructuredBuffer<float3> _LODDistanceBuffer;

//Args数据
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;   //ArgsBuffer
uint _ItemCount;//总物体数量
uint _RenderTypeCount;//总类型数量


// 更精确的包围盒测试
bool AABBInFrustum(float3 center, float3 extents)
{
    for (int i = 0; i < 6; i++)
    {
        float4 plane = _FrustumPlanesBuffer[i];
        float3 normal = plane.xyz;
        
        // 计算包围盒在平面法线方向上的投影半径
        float r = extents.x * abs(normal.x) + 
                  extents.y * abs(normal.y) + 
                  extents.z * abs(normal.z);
                  
        float distance = dot(normal, center) + plane.w;
        
        if (distance < -r) return false;
    }
    return true;
}

//假定的Group已经做过视锥剔除了 那么这个阶段主要做的就是Item级别的剔除
[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint itemIndex = id.x;
    
    if (itemIndex >= _ItemCount)
        return;

    //已经在CPU阶段被剔除了 跳过
    if (_CullResultBuffer[itemIndex] == false)
    {
        return;
    }

    //TODO
    bool isGroupVisible = true;
    if (!isGroupVisible)
    {
        //连组都不可见了
        _CullResultBuffer[itemIndex] = false;
        return;
    }
    
    Bounds bounds = _BoundsBuffer[itemIndex];

    bool isVisible = true;

    if (isVisible) isVisible = AABBInFrustum(bounds.position, bounds.extents);
    if (isVisible) isVisible = IsOcclusionVisible(bounds.position, 1, 1, 1);
    
    _CullResultBuffer[itemIndex] = isVisible;

    //距离剔除
    int typeID = _RenderIDBuffer[itemIndex];
    float3 lodDistance = _LODDistanceBuffer[typeID];
    float distanceFromCamera = distance(_CameraPosition, bounds.position);
    if (distanceFromCamera >= lodDistance.z)
    {
        isVisible = false;
    }

    _CullResultBuffer[itemIndex] = isVisible;
    
    if (isVisible)
    {
        //再来判断LOD
        int lodLevel = CalcLODLevel(distanceFromCamera, lodDistance);
        _LODLevelBuffer[itemIndex] = lodLevel;
       
        InterlockedAdd(_IndirectArgsBuffer[typeID * LOD_LEVEL + lodLevel].numInstances, 1);

        //后续LODLevel后移
        for (int i = lodLevel+1; i < LOD_LEVEL; i++)
        {
            InterlockedAdd(_IndirectArgsBuffer[typeID * LOD_LEVEL + i].startLocation, 1);
        }

        //后续的其他render 后移
        for (uint l = typeID + 1; l < _RenderTypeCount; l++)
        {
            //各个LOD级别一起后移
            InterlockedAdd(_IndirectArgsBuffer[l * LOD_LEVEL + 0].startLocation, 1);
            InterlockedAdd(_IndirectArgsBuffer[l * LOD_LEVEL + 1].startLocation, 1);
            InterlockedAdd(_IndirectArgsBuffer[l * LOD_LEVEL + 2].startLocation, 1);
        }
    }
}